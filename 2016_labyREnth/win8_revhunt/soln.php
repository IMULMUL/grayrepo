<?php
$flag = array();
$flag[0x69] = 0x50; // P
$flag[0x68] = 0x41; // A
$flag[0x67] = 0x4e; // N
$flag[0x66] = 0x7b; // {

$tmp = convertLittleEndian(dechex(0x366C734A ^ 0x1A1B1C1D));
$tmp = extendToEvenLength($tmp);
addToFlag($flag, $tmp, 0x65);

$flag[0x61] = (0xb0 ^ 0xf0) >> 1;
$flag[0x60] = (0x56 ^ 0x20) - 4;

// "8888999900001110"
// "a9fafcea72656770"
$tmp = convertLittleEndian(dechex(0x00001110 ^ 0x72656770));
// Guessing 0x5f to be 'e' char 0x5f = 0x60 but it was anded with 0xf0, therefore it could be 0x60-0x6f
// $flag[0x5f] = 0x3f; // put temporary ?
$flag[0x5f] = 0x65;
$tmp = substr($tmp,2);
addToFlag($flag, $tmp, 0x5e);
$tmp = convertLittleEndian(dechex(0x88889999 ^ 0xa9fafcea));
addToFlag($flag, $tmp, 0x5b);

// checkFlag1
$flag[0x57] = 0x20;
$flag[0x56] = 0x67 - 0x20;
$flag[0x55] = 0x72 & 0x3fffffff;
$flag[0x54] = 0xfc ^ 0x99;
$flag[0x53] = (0xc3 + 0x60) / 3;
$flag[0x52] = 0x3b ^ 0x4f;
$flag[0x51] = 0x20;
$flag[0x50] = (0x71 - 0xf) ^ 0xf;
$flag[0x4f] = (0x81 ^ 0x21) - 0x31; //rbx+8
$flag[0x4e] = 0x46 + 0x30;
$flag[0x4d] = (0x1 ^ 0x58) + 0xc;
$flag[0x4c] = 0x73;

// checkFlag2 (starts from 0x29 == 0x4b) (0x29 is a tmp buffer??)
$flag[0x4b] = 0x2c; // 0x29, rbx
// missing 0x4a, rbx+1
$flag[0x4a] = 0x20; // Guessing 0x4a
$flag[0x49] = 0x1ac0 >> 6; // 0x27, rbx+2
$flag[0x48] = (0x308 + 0x20) / 8; // 0x26, rbx+3
$flag[0x47] = ((0xe002 ^ 0xf2f2) >> 4) / 3; // 0x25, rbx+4
$flag[0x46] = (0x9542 ^ 0x8942) >> 6; // 0x24, rbx+5
// missing 0x45, rbx+6
$flag[0x45] = 0x20; // Guessing 0x45
$flag[0x44] = ((0x834 << 2) >> 4) / 5; // 0x22, rbx+7
$flag[0x43] = (0x94dd ^ 0x83c1) / 0x33; // 0x21, rbx+8
$flag[0x42] = 0x1f + 1; // 0x20, rbx+9
$flag[0x41] = (0x1dd36c ^ 0x46) / 0x4142;// 0x1a, rbx+f
$flag[0x40] = 0x328250 / 0x7373; // 0x19, rbx+10
$flag[0x3f] = 0x2d - 1; // 0x18, rbx+11

// checkFlag3 (starts from 0x29 == 0x3f)
$flag[0x3e] = 0x40 - 0x20; // 0x28, rbx+1
$flag[0x3d] = (0xd7 ^ 0x44) - 0x23; // 0x27, rbx+2
$flag[0x3c] = (0xb2 ^ 0x21) - 0x21; // 0x26, rbx+3
$flag[0x3b] = (0x238 - 0x7c) / 4; // first num can be 0x*38, 0x25, rbx+4
$flag[0x3a] = (0x8f25 ^ 0x8875) >> 4; // 0x24, rbx+5
$flag[0x39] = ((0xd6 ^ 0xe4) / 2) << 2; // 0x23, rbx+6
$flag[0x38] = (0x62 ^ 0x42); //0x22, 0x1e, rbx+7

// checkFlag4 (starts from 0x1e == 0x38)
$flag[0x37] = (0x70d49 ^ 0x48354) / 0x833; // 0x1d, rbx+1
$flag[0x36] = (0x14c3a1 ^ 0x232221) / 0x8c40; // 0x1c, rbx+2
$flag[0x35] = 0xa0 - 0x80; // 0x1b, rbx+3

// checkFlag5 (starts from 0x16 == 0x34)
$flag[0x34] = 0x5c ^ 0x25; // 0x16, rbx
$flag[0x33] = (0x20f63 ^ 0x23) / 0x4c0; // 0x15, rbx+1
$flag[0x32] = (0x242067 ^ 0x12567) / 0x5100; // 0x14, rbx+2
$flag[0x31] = ((0x61 ^ 0x21) >> 6) + 0x20; // 0x13, rbx+3
$flag[0x30] = (((0x13f ^ 0x903) / 0x44) << 2) + 1; // 0x12, rbx+4

printFlag($flag,0x40);
// flag is PAN{Wow, reverser! Great moves, keep it up, proud of you!}

function addToFlag(&$flag, $newdata, $index){
	$newdata = extendToEvenLength($newdata);
	for ($i=0; $i<strlen($newdata); $i+=2){
		$cur = substr($newdata, $i, 2);
		$flag[$index--] = hexdec($cur);
	}
}

function convertLittleEndian($hexstr){
	if (strlen($hexstr) > 8) return false;
	$hexstr = extendToEvenLength($hexstr);
	
	$out = "";
	$b1 = substr($hexstr,6,2);
	$b2 = substr($hexstr,4,2);
	$b3 = substr($hexstr,2,2);
	$b4 = substr($hexstr,0,2);
	return $b1.$b2.$b3.$b4;
}

function extendToEvenLength($hex){
	while (strlen($hex) % 2 !== 0) $hex = '0'.$hex;
	return $hex;
}

function printFlag($flag, $len){
	$startindex = 0x69;
	$out = "";
	for ($i=0; $i<$len; $i++){
		if (empty($flag[$startindex-$i])) $out .= "*";
		else{
			$cur = $flag[$startindex-$i];
			$out .= chr($cur);
		}
	}
	echo $out."\n";
}
?>